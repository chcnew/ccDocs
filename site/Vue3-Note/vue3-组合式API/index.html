
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="个人知识笔记与技术文档">
      
      
        <meta name="author" content="HC">
      
      
        <link rel="canonical" href="https://chcnew.github.io/ccDocs/Vue3-Note/vue3-%E7%BB%84%E5%90%88%E5%BC%8FAPI/">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>vue3-组合式API - CC学习文档库</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#vue3-api" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="CC学习文档库" class="md-header__button md-logo" aria-label="CC学习文档库" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CC学习文档库
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              vue3-组合式API
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../Python-Note/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="md-tabs__link">
          
  
  
  Python 学习笔记

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../Python-Note/FastAPI-Note/" class="md-tabs__link">
          
  
  
  FastAPI 系列

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="CC学习文档库" class="md-nav__button md-logo" aria-label="CC学习文档库" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    CC学习文档库
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Python 学习笔记
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Python 学习笔记
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Python-Note/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    并发编程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Python-Note/DRF-Note/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    DRF 框架
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    FastAPI 系列
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            FastAPI 系列
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Python-Note/FastAPI-Note/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FastAPI 入门
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="vue3-api">vue3-组合式API</h1>
<p>vue3项目支持组合式与选项式API，更多人推荐组合式API语法，它能更好的规划代码结构，按功能块划分更易维护。</p>
<h1 id="api-setup">一、组合式API--入口-setup函数</h1>
<h2 id="1">1 非语法糖写法</h2>
<pre><code class="language-vue">&lt;template&gt;&lt;/template&gt;

&lt;script&gt;
// 组合式API学习 -- 非语法糖写法
export default {
  // 最先执行的函数
  setup() {
    console.log(&quot;setup&quot;);

    const message = &quot;hello&quot;;
    const printMessage = (someValue = message) =&gt; {
      console.log(someValue);
    };

    return {
      message,
      printMessage,
    };
  },

  // 生命周期函数
  beforeCreate() {
    console.log(&quot;beforeCreate&quot;);
    this.printMessage(&quot;this is in beforeCreate message&quot;);
  },
};
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="2">2 语法糖写法(推荐)</h2>
<pre><code class="language-vue">&lt;template&gt;&lt;/template&gt;

&lt;script setup&gt;
// 组合式API学习 -- 语法糖写法
import { onBeforeMount } from &quot;vue&quot;;  // 这里需要注意的是：组合式API生命周期函数不会有：onBeforeCreate -&gt; onCreate，setup函数阶段在他们之前

console.log(&quot;setup&quot;);

const message = &quot;hello&quot;;
const printMessage = (someValue = message) =&gt; {
  console.log(someValue);
};

onBeforeMount(() =&gt; {
  console.log(&quot;onBeforeMount&quot;);
  printMessage(&quot;this is in beforeCreate message&quot;);
});
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="3">3 总结</h2>
<ol>
<li><strong>setup选项的执行时机?</strong></li>
</ol>
<p>beforeCreate钩子之前 自动执行</p>
<ol>
<li><strong>setup写代码的特点是什么?</strong></li>
</ol>
<p>定义数据+函数 然后以对象方式return</p>
<ol>
<li><strong><code>&lt;script setup&gt;</code>解决了什么问题?</strong></li>
</ol>
<p>经过语法糖的封装更简单的使用组合式API;</p>
<p>此时的变量不再需要return，定义即可使用</p>
<ol>
<li><strong>setup中的this还指向组件实例吗?</strong></li>
</ol>
<p>不是，它指向undefined</p>
<h1 id="api-reactiveref">二、组合式API--reactive和ref函数</h1>
<h2 id="1-reactive">1 reactive 响应式对象</h2>
<p><strong>作用：接受对象类型数据的参数传入，并返回一个响应式的对象</strong></p>
<pre><code class="language-vue">&lt;script setup&gt;
import { reactive } from 'vue'

// 推导得到的类型：{ title: string }
const book = reactive({ title: 'Vue 3 指引' })
&lt;/script&gt;
</code></pre>
<p>示例：计数器自增显示</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;{{ stateData.count }}&lt;/h4&gt;
  &lt;button @click=&quot;addCount&quot;&gt;addCount&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive } from &quot;vue&quot;;

const stateData = reactive({
  count: 0,
});

const addCount = () =&gt; {
  stateData.count++;
};
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<h2 id="2-ref">2 ref 响应式对象</h2>
<p><strong>作用：接受对象类型或简单类型数据的参数传入，并返回一个响应式的对象</strong></p>
<p><strong>注意：ref修改值需要通过 变量.value 属性处理</strong></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;{{ count }}&lt;/h4&gt;
  &lt;button @click=&quot;addCount&quot;&gt;addCount&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from &quot;vue&quot;;

const count = ref(0);

const addCount = () =&gt; {
  console.log(&quot;count:&quot;, count);
  count.value++;  // 注意：ref修改值需要通过.value属性处理
};
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="3_1">3 总结</h2>
<ol>
<li><strong>reactive和ref函数的共同作用是什么?</strong></li>
</ol>
<p>用函数调用的方式生成响应式数据</p>
<ol>
<li><strong>reactive vs ref ?</strong></li>
</ol>
<p>1）reactive不能处理简单类型的数据</p>
<p>2）ref参数类型支持更好但是必须通过,value访问修改</p>
<p>3）ref函数的内部实现依赖于reactive函数</p>
<ol>
<li><strong>在实际工作中推荐使用哪个?</strong></li>
</ol>
<p>推荐使用ref函数，更加灵活</p>
<h1 id="api-computed">三、组合式API--computed函数</h1>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;
    computed -
    动态计算属性（注意：只能做计算，不要干其他事；如果需要副作用，可以交给watch函数）
  &lt;/h4&gt;
  &lt;p&gt;原始数据：{{ srcList }}&lt;/p&gt;
  &lt;p&gt;计算数据：{{ tarList }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { computed, ref } from &quot;vue&quot;; // 定义响应式数据对象

// 定义响应式数据对象
const srcList = ref([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

// 定义计算函数对象 - 注意：不要有其他”副作用“功能代码，这里只能有计算逻辑
const tarFunc = () =&gt; {
  return srcList.value.filter((item) =&gt; item &gt; 5);
};

// 使用computed绑定对应计算函数（入参必须为函数有返回值函数对象）
const tarList = computed(tarFunc);

// 延时设置原始数据变化，计算值也会变化
setTimeout(() =&gt; {
  srcList.value.push(11, 12, 13, 14, 15);
}, 3000);
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>计算属性函数中不应该有“副作用”</strong></li>
</ol>
<p>比如异步请求、修改dom</p>
<ol>
<li><strong>避免直接修改计算属性的值</strong></li>
</ol>
<p>计算属性应该是只读的</p>
<h1 id="api-watch">四、组合式API--watch函数</h1>
<p><strong>侦听器：</strong>watch函数</p>
<p><strong>作用：</strong>侦听一个或者多个数据的变化，数据变化时执行回调函数</p>
<p><strong>两个额外参数：</strong>immediate（立即执行）、deep（深度侦听）</p>
<h2 id="1_1">1 侦听数据对象（单个/多个）</h2>
<ol>
<li>导入watch函数</li>
<li>执行watch函数传入 要侦听的响应式数据(注意：ref对象本身，不需要.value) 和 回调函数</li>
</ol>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;watch - 侦听器&lt;/h4&gt;

  &lt;p&gt;简单类型 - 单个数据对象：{{ count }}&lt;/p&gt;
  &lt;button @click=&quot;count++&quot;&gt;changeValue&lt;/button&gt;

  &lt;hr /&gt;

  &lt;p&gt;简单类型 - 多个数据对象1：{{ number }}&lt;/p&gt;
  &lt;p&gt;简单类型 - 多个数据对象2：{{ name }}&lt;/p&gt;
  &lt;button @click=&quot;changeMultiple1&quot;&gt;changeMultiple1&lt;/button&gt;
  &lt;button @click=&quot;changeMultiple2&quot;&gt;changeMultiple2&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, watch } from &quot;vue&quot;; // 定义响应式数据对象

// 定义响应式数据对象
const count = ref(0);
const number = ref(0);
const name = ref(&quot;chc&quot;);

// 传入单个响应式数据对象本身+回调函数
watch(count, (newVal, oldVal) =&gt; {
  console.log(&quot;count 已发生变化&quot;, count.value, newVal, oldVal);
});

const changeMultiple1 = () =&gt; {
  number.value++;
};
const changeMultiple2 = () =&gt; {
  name.value = &quot;cenhongchang&quot;;
};

// 传入多个响应式数据对象本身+回调函数
watch(
  [number, name],
  ([newNumberVal, newNameVal], [oldNumberVal, oldNameVal]) =&gt; {
    console.log(
      &quot;number 或 name 已发生变化&quot;,
      newNumberVal,
      newNameVal,
      oldNumberVal,
      oldNameVal,
    );
  },
);
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="2-immediate">2 immediate（立即执行)）</h2>
<p>实现输入框，根据输入内容显示下拉选择项的需求，常常一开始上来没有输入是，默认执行一次从后端获取可选项，这时用到：immediate</p>
<p>注意：立即执行时，变量还未创建，所以oldVal = undefined；但 newVal = 0</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;watch - 侦听器&lt;/h4&gt;

  &lt;p&gt;简单类型 - 单个数据对象：{{ count }}&lt;/p&gt;
  &lt;button @click=&quot;count++&quot;&gt;changeValue&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, watch } from &quot;vue&quot;; // 定义响应式数据对象

const count = ref(0);

// immediate - 立即执行测试
watch(
  count,
  (newVal, oldVal) =&gt; {
    console.log(&quot;count 已发生变化&quot;, count.value, newVal, oldVal);
  },
  { immediate: true }, // 开启立即执行
);
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="3-deep">3 deep（深度侦听）与精确侦听（对象数据）</h2>
<p>默认机制：<strong>通过watch监听的ref对象默认是浅层侦听的</strong>，直接修改嵌套的对象属性不会触发回调执行，需要开启deep选项</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;watch - 侦听器&lt;/h4&gt;

  &lt;p&gt;简单类型 - 对象：{{ data }}&lt;/p&gt;
  &lt;button @click=&quot;data.count++&quot;&gt;changeCountValue&lt;/button&gt;
  &lt;button @click=&quot;changeNameValue&quot;&gt;changeNameValue&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, watch } from &quot;vue&quot;;

const data = ref({
  name: &quot;chc&quot;,
  age: 18,
  count: 0,
});

// 精确侦听 - 只侦听count数据变化 - 第一个参数改为传入 获取对应字段的回调函数
watch(
  () =&gt; {
    return data.value.count;
  },
  (newVal, oldValue) =&gt; {
    console.log(&quot;count 已发生变化&quot;, data.value, newVal, oldValue);
  },
);

const changeNameValue = () =&gt; {
  data.value.name += &quot;A&quot;;
};
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="4-oldval">4 深度侦听oldVal值处理</h2>
<p><strong>注意：深度侦听时，oldVal值将不会被保存，需要自行处理</strong></p>
<p>示例：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h4&gt;watch - 侦听器&lt;/h4&gt;

  &lt;p&gt;简单类型 - 数组：{{ dataList }}&lt;/p&gt;
  &lt;button @click=&quot;dataList.pop()&quot;&gt;changeValue&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, watch } from &quot;vue&quot;;

const dataList = ref([1, 2, 3, 4, 5]);
let previousValue = [...dataList.value]; // 保存初始值的副本

watch(
  dataList,
  (newVal) =&gt; {
    console.log(&quot;count 已发生变化&quot;, dataList.value, newVal, previousValue);
    previousValue = [...newVal];
  },
  { deep: true },
);
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p>tips:  有返回值函数等价写法</p>
<pre><code class="language-ts">() =&gt; {
    return data.value.count;
}

() =&gt; data.value.count
</code></pre>
<h2 id="5">5 总结</h2>
<ol>
<li><strong>作为watch函数的第一个参数，ref对象需要添加.value吗?</strong></li>
</ol>
<p>不需要，watch会自动读取</p>
<ol>
<li><strong>watch只能侦听单个数据吗?</strong></li>
</ol>
<p>单个或者多个</p>
<ol>
<li><strong>不开启deep，直接修改嵌套属性能触发回调吗?</strong></li>
</ol>
<p>不能，默认是浅层侦听</p>
<ol>
<li><strong>不开启deep，想在某个层次比较深的属性变化时执行回调怎么做?</strong></li>
</ol>
<p>可以把第一个参数写成函数的写法，返回要监听的具体属性</p>
<h2 id="6-watch">6 扩展 - watch相关函数</h2>
<ul>
<li>🔍 <code>watch</code>：指定监听谁（精准侦听）</li>
</ul>
<p>```ts
  import { ref, watch } from 'vue'</p>
<p>const count = ref(0)</p>
<p>watch(count, (newVal, oldVal) =&gt; {
    console.log('count 变化:', oldVal, '-&gt;', newVal)
  })
  ```</p>
<ul>
<li>⚙️ <code>watchEffect</code>：自动侦听一切依赖</li>
</ul>
<p>```ts
  import { ref, watchEffect } from 'vue'</p>
<p>const count = ref(0)
  const double = ref(0)</p>
<p>watchEffect(() =&gt; {
    double.value = count.value * 2
    console.log('自动监听到 count 变化:', count.value)
  })
  ```</p>
<ul>
<li>🕒 <code>watchSyncEffect</code>：同步执行（DOM 更新前）</li>
</ul>
<p>```ts
  import { ref, watchSyncEffect } from 'vue'</p>
<p>const message = ref('Hello')</p>
<p>watchSyncEffect(() =&gt; {
    console.log('同步执行：', message.value)
  })
  ```</p>
<ul>
<li>🕞 <code>watchPostEffect</code>：异步执行（DOM 更新后）</li>
</ul>
<p>```ts
  import { ref, watchPostEffect } from 'vue'</p>
<p>const text = ref('Hi')</p>
<p>watchPostEffect(() =&gt; {
    console.log('DOM 更新后执行:', text.value)
  })
  ```</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>是否自动收集依赖</th>
<th>执行时机</th>
<th>是否立即执行</th>
<th>常见用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>watch</code></td>
<td>否（需手动指定）</td>
<td>异步（更新后）</td>
<td>否（可设 immediate）</td>
<td>精确监听指定变量</td>
</tr>
<tr>
<td><code>watchEffect</code></td>
<td>✅ 自动收集</td>
<td>渲染前</td>
<td>✅ 是</td>
<td>常规副作用、打印、请求</td>
</tr>
<tr>
<td><code>watchSyncEffect</code></td>
<td>✅ 自动收集</td>
<td>渲染前（同步）</td>
<td>✅ 是</td>
<td>同步更新逻辑</td>
</tr>
<tr>
<td><code>watchPostEffect</code></td>
<td>✅ 自动收集</td>
<td>渲染后（异步）</td>
<td>✅ 是</td>
<td>DOM 操作、动画、UI 库更新</td>
</tr>
</tbody>
</table>
<h1 id="api-">五、组合式API--生命周期函数</h1>
<h2 id="1_2">1 组件生命周期钩子对照表</h2>
<table>
<thead>
<tr>
<th>阶段</th>
<th>Options API 钩子</th>
<th>Composition API 钩子</th>
<th>核心动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建前</td>
<td><code>beforeCreate</code></td>
<td>（无）</td>
<td>初始化事件、依赖注入，但还未建立响应式</td>
</tr>
<tr>
<td>创建后</td>
<td><code>created</code></td>
<td><code>setup()</code>（逻辑入口）</td>
<td>响应式系统建立，<code>data</code>、<code>props</code>、<code>methods</code> 可用</td>
</tr>
<tr>
<td>挂载前</td>
<td><code>beforeMount</code></td>
<td><code>onBeforeMount</code></td>
<td>模板编译成 render 函数，DOM 尚未渲染</td>
</tr>
<tr>
<td>挂载后</td>
<td><code>mounted</code></td>
<td><code>onMounted</code></td>
<td>虚拟 DOM 已生成并挂载到真实 DOM</td>
</tr>
<tr>
<td>更新前</td>
<td><code>beforeUpdate</code></td>
<td><code>onBeforeUpdate</code></td>
<td>响应式数据变化触发虚拟 DOM diff 但尚未重新渲染</td>
</tr>
<tr>
<td>更新后</td>
<td><code>updated</code></td>
<td><code>onUpdated</code></td>
<td>DOM 已更新到最新状态</td>
</tr>
<tr>
<td>卸载前</td>
<td><code>beforeUnmount</code></td>
<td><code>onBeforeUnmount</code></td>
<td>组件即将销毁，可清理事件/定时器</td>
</tr>
<tr>
<td>卸载后</td>
<td><code>unmounted</code></td>
<td><code>onUnmounted</code></td>
<td>实例完全销毁，响应式解绑</td>
</tr>
</tbody>
</table>
<h2 id="2_1">2 钩子函数可以执行多次</h2>
<p>适用场景示例：接手别人的代码，不要动别人的 onMounted 函数，继续写自己的逻辑</p>
<pre><code class="language-vue">&lt;template&gt;&lt;/template&gt;

&lt;script setup&gt;
import { onMounted } from &quot;vue&quot;;

onMounted(() =&gt; {
  console.log(&quot;mounted-1&quot;);
});

onMounted(() =&gt; {
  console.log(&quot;mounted-2&quot;);
});

onMounted(() =&gt; {
  console.log(&quot;mounted-3&quot;);
});
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="3_2">3 总结</h2>
<ol>
<li><strong>组合式API中生命周期函数的格式是什么?</strong></li>
</ol>
<p>on+ 生命周期名字</p>
<ol>
<li><strong>组合式API中可以使用onCreated吗?</strong></li>
</ol>
<p>没有这个钩子函数，直接写到setup中</p>
<ol>
<li><strong>组合式API中组件卸载完毕时执行哪个函数?</strong></li>
</ol>
<p>onUnmounted</p>
<h1 id="api-_1">五、组合式API--父子通信-父传子</h1>
<p><strong>基本思想</strong>：</p>
<ol>
<li>
<p>父组件中给子组件绑定属性</p>
</li>
<li>
<p>子组件内部通过props选项接收</p>
</li>
</ol>
<p><strong>父组件</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from &quot;vue&quot;;
import Child from &quot;@/components/DataSend1/Child.vue&quot;;

const name = ref(&quot;CCPLAYER(父组件定义1)&quot;);
const personCount = ref(0);
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;父组件：&lt;/p&gt;
  &lt;p&gt;name：{{ name }}&lt;/p&gt;
  &lt;p&gt;personCount：{{ personCount }}&lt;/p&gt;
  &lt;button @click=&quot;personCount++&quot;&gt;addPersonCount&lt;/button&gt;
  &lt;Child :name=&quot;name&quot; :personCount=&quot;personCount&quot; /&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p><strong>子组件</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
// 接收父组件数据 - defineProps：编译器宏函数，无需导入，会将对应代码编译
const props = defineProps({
  name: String,
  personCount: Number,
});

console.log(props.name);
console.log(props.personCount);
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;div class=&quot;card-header bg-info&quot;&gt;BOOTSTRAP-CARD&lt;/div&gt;
    &lt;div class=&quot;card-body&quot;&gt;
      &lt;p&gt;子组件：&lt;/p&gt;
      &lt;p&gt;name：{{ name }} &lt;- 父传子数据&lt;/p&gt;
      &lt;p&gt;personCount={{ personCount }} &lt;- 父传子数据&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h1 id="api-_2">六、组合式API--父子通信-子传父</h1>
<p><strong>基本思想</strong></p>
<ol>
<li>
<p>父组件中给子组件标签通过@绑定事件</p>
</li>
<li>
<p>子组件内部通过 $emit 方法触发事件</p>
</li>
</ol>
<p><strong>父组件</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from &quot;vue&quot;;
import Child from &quot;@/components/DataSend2/Child.vue&quot;;

const name = ref(&quot;CCPLAYER(父组件定义2)&quot;);
const childData = ref(&quot;&quot;);

// 父组件作用域函数
const getMessage = (data) =&gt; {
  childData.value = data;
};
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;父组件&lt;/p&gt;
  &lt;p&gt;name：{{ name }}&lt;/p&gt;
  &lt;p&gt;data：{{ childData }} &lt;- 子传父数据&lt;/p&gt;
  &lt;Child @get-message=&quot;getMessage&quot; /&gt;
  &lt;!-- get-message 对应子组件自定义事件 --&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p><strong>子组件</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
// 编译器宏函数编译获取emit方法
const emit = defineEmits([&quot;get-message&quot;]);

const getChildData = () =&gt; {
  // 点击触发自定义函数，同时使用emit方法传递数据给父组件 自定义事件 get-message
  emit(&quot;get-message&quot;, &quot;CHILD-子组件数据&quot;);
};
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;div class=&quot;card-header bg-info&quot;&gt;BOOTSTRAP-CARD&lt;/div&gt;
    &lt;div class=&quot;card-body&quot;&gt;
      &lt;p&gt;子组件：&lt;/p&gt;
      &lt;button @click=&quot;getChildData&quot;&gt;发送数据给父组件&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p><strong>总结</strong>：</p>
<p><strong>父传子</strong></p>
<ol>
<li><strong>父传子的过程中通过什么方式接收props?</strong></li>
</ol>
<p>defineProps({属性名：类型})</p>
<ol>
<li><strong>setup语法糖中如何使用父组件传过来的数据?</strong></li>
</ol>
<p>constprops=defineProps({属性名：类型})</p>
<p><strong>子传父</strong></p>
<ol>
<li><strong>子传父的过程中通过什么方式得到emit方法?</strong></li>
</ol>
<p>defineEmits([‘事件名称])</p>
<h1 id="api-ref">七、组合式API--模板引用(ref)</h1>
<p>通过ref标识获取真实的dom对象或者组件实例对象</p>
<p>实现步骤：</p>
<ol>
<li>调用ref函数生成一个ref对象</li>
<li>通过ref标识绑定ref对象到标签</li>
</ol>
<p><strong>父组件</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import RefChildDemo from &quot;./RefChildDemo.vue&quot;;
import { onMounted, ref } from &quot;vue&quot;;

// 响应式数据
const message = ref(&quot;测试REF&quot;);

// 模板引用
const cRef = ref();
const zRef = ref();

// 组件挂载完毕自动获取打印
onMounted(() =&gt; {
  console.log(&quot;cRef.value:&quot;, cRef.value); // 获取DOM元素
  console.log(&quot;zRef.value:&quot;, zRef.value); // 获取子组件实例对象
  console.log(&quot;zRef.value.name:&quot;, zRef.value.name); // 获取子组件实例对象name属性
  zRef.value.setName(&quot;张三&quot;);  // 调用子组件setName函数
  console.log(&quot;zRef.value.name:&quot;, zRef.value.name); // 在此获取子组件实例对象name属性（已修改）
});

// 方法
const getData = () =&gt; {
  console.log(cRef.value.innerHTML);
};
&lt;/script&gt;

&lt;template&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;div ref=&quot;cRef&quot;&gt;
    &lt;span&gt;{{ message }}&lt;/span&gt;
    &lt;button @click=&quot;getData&quot;&gt;点击测试获取DOM&lt;/button&gt;
  &lt;/div&gt;
  &lt;hr /&gt;
  &lt;hr /&gt;
  &lt;RefChildDemo ref=&quot;zRef&quot; /&gt;
  &lt;hr /&gt;
  &lt;hr /&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<p><strong>子组件</strong>：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from &quot;vue&quot;;

const name = ref(&quot;&quot;);

const setName = (tarName) =&gt; {
  name.value = tarName;
};

// 默认情况下在&lt;script setup&gt;语法糖下组件内部的属性和方法是不开放给父组件访问的，可以通过defineExpose编译宏指定哪些属性和方法
// 编译器宏函数主动暴露变量给父组件的模板引用
defineExpose({
  name,
  setName,
});
&lt;/script&gt;

&lt;template&gt;
  &lt;h4&gt;{{ name }}：我是组件-&gt;RefChildDemo&lt;/h4&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h1 id="api-_3">七、组合式API--跨层组件通信(依赖注入)</h1>
<p>作用和场景：顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信</p>
<p>跨层传递普通数据：</p>
<ol>
<li>
<p>顶层组件通过provide函数提供数据 --&gt; <code>provide("key", 顶层组件数据-可以是响应式数据ref对象)</code></p>
</li>
<li>
<p>底层组件通过inject函数获取数据 --&gt; <code>const message inject("key")</code></p>
</li>
</ol>
<h2 id="1_3">1 顶层组件</h2>
<pre><code class="language-vue">&lt;script setup&gt;
import { onMounted, onUnmounted, provide, ref } from &quot;vue&quot;;
import RoomMsgItem from &quot;./RoomMsgItem.vue&quot;;

// 组件嵌套关系：RoomPage -&gt; RoomMsgItem -&gt; RoomMsgComment

// 顶层组件提供数据
provide(&quot;data-key&quot;, 'This is &quot;RoomPage&quot; data');

// 传递响应式数据
const count = ref(0);
provide(&quot;count-key&quot;, count);

let timeCount = ref(3);
let timer = null;

const isTimerCompleted = ref(false); // 定时器是否完成状态
provide(&quot;isTimerCompleted-key&quot;, isTimerCompleted);

const setCount = (value) =&gt; {
  if (isTimerCompleted.value) {
    count.value = value;
  } else {
    alert(&quot;请等待定时器完成！&quot;);
  }
};
provide(&quot;setCount-key&quot;, setCount); // 传递的不止可以是数据对象，也可以是函数对象

onMounted(() =&gt; {
  timer = setInterval(() =&gt; {
    if (timeCount.value &gt; 0) {
      timeCount.value--;
      if (timeCount.value === 0) {
        count.value = 10000;
        isTimerCompleted.value = true; // 定时器已执行完成
      }
    } else {
      clearInterval(timer);
    }
  }, 1000);
});

onUnmounted(() =&gt; {
  if (timer) {
    clearInterval(timer);
  }
});
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;h4&quot;&gt;
    顶层组件 -&gt; 数据传送倒计时：{{ timeCount }}
    &lt;span v-if=&quot;isTimerCompleted&quot; class=&quot;text-success ms-2&quot;
      &gt;✓ 定时器已完成&lt;/span
    &gt;
    &lt;RoomMsgItem class=&quot;ms-4 mt-4&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="2_2">2 中间组件</h2>
<pre><code class="language-vue">&lt;script setup&gt;
import RoomMsgComment from &quot;./RoomMsgComment.vue&quot;;
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;h5 ms-4 mt-4&quot;&gt;
    中间组件
    &lt;RoomMsgComment /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="3_3">3 底层组件</h2>
<pre><code class="language-vue">&lt;script setup&gt;
// 底层组件接收数据
import { inject } from &quot;vue&quot;;

const data = inject(&quot;data-key&quot;);
const count = inject(&quot;count-key&quot;);
const isTimerCompleted = inject(&quot;isTimerCompleted-key&quot;);
const setCount = inject(&quot;setCount-key&quot;);
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;h6 ms-4 mt-4&quot;&gt;
    底层组件
    &lt;br /&gt;
    &lt;span&gt;来自顶层组件的固定数据：{{ data }}&lt;/span&gt;
    &lt;br /&gt;
    &lt;span&gt;来自顶层组件的响应式数据：{{ count }}&lt;/span&gt;
    &lt;br /&gt;
    &lt;span&gt;点击修改顶层组件的响应式数据：&lt;/span&gt;
    &lt;button @click=&quot;setCount(88888)&quot;&gt;DoIt&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>
<h2 id="4">4 总结</h2>
<ol>
<li><strong>provide和inject的作用是什么?</strong></li>
</ol>
<p>跨层组件通信</p>
<ol>
<li><strong>如何在传递的过程中保持数据响应式?</strong></li>
</ol>
<p>第二个参数传递ref对象</p>
<ol>
<li><strong>底层组件想要通知顶层组件做修改，如何做?</strong></li>
</ol>
<p>传递方法，底层组件调用方法</p>
<ol>
<li><strong>一颗组件树中只有一个顶层或底层组件吗?</strong></li>
</ol>
<p>相对概念，存在多个顶层和底层的关系</p>
<h1 id="axios">八、axios(网络请求插件)</h1>
<p>官方网站：https://axios-http.com/zh/docs/intro</p>
<p>安装命令：</p>
<pre><code class="language-shell">npm install axios
# 或
pnpm add axios
</code></pre>
<p>pnpm操作：</p>
<pre><code class="language-shell"># 删除 node_modules 目录
rm -rf node_modules

# 删除 pnpm 锁文件
rm -rf pnpm-lock.yaml

# 清理 pnpm 缓存（可选但推荐）
pnpm store prune
</code></pre>
<p>get请求示例：</p>
<pre><code class="language-vue">&lt;script lang=&quot;ts&quot; setup&gt;
import { ref } from &quot;vue&quot;;
import axios, { AxiosResponse } from &quot;axios&quot;; // 定义返回数据接口

// 定义返回数据接口
interface ApiResponse {
  projects: string[];
  versions: string[];
}

const versions = ref([]);
setTimeout(() =&gt; {
  axios
    .get(
      &quot;http://localhost:9777/api/get-projects-and-versions?platform=MTK6993&quot;,
    )
    .then((res: AxiosResponse&lt;ApiResponse&gt;) =&gt; {
      console.log(&quot;data&quot;, res.data.versions); // 定义接口之后，这里就不会提示没有该字段
      versions.value = res.data.versions;
    });
}, 3000);
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;div class=&quot;card-header&quot;&gt;测试网络请求获取数据&lt;/div&gt;
    &lt;div class=&quot;card-body&quot;&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;(item, index) in versions&quot; :key=&quot;index&quot;&gt;
          {{ item }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;&lt;/style&gt;

</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "navigation.tabs", "search.highlight", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>